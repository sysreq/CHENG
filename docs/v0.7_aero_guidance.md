# CHENG v0.7 Aerospace Engineering Guidance

> **Author:** Senior Aerospace Engineering Agent
> **Date:** 2026-02-24
> **Version:** 1.0
> **Purpose:** Pre-implementation engineering reference for the five v0.7 issues.
> Worker agents implementing v0.7 must read this document in full before writing any
> code. All guidance herein supersedes general intuition. When guidance conflicts with
> other docs, follow `docs/mvp_spec.md` first, then this document.

---

## Table of Contents

1. [Issue #143 — Multi-section Wings](#1-issue-143--multi-section-wings)
2. [Issue #144 — Control Surfaces](#2-issue-144--control-surfaces)
3. [Issue #145 — Landing Gear](#3-issue-145--landing-gear)
4. [Issue #146 — Test Joint Feature](#4-issue-146--test-joint-feature)
5. [Issue #147 — Smart Split-Point Optimizer](#5-issue-147--smart-split-point-optimizer)
6. [Cross-Cutting Engineering Constraints](#6-cross-cutting-engineering-constraints)

---

## 1. Issue #143 — Multi-section Wings

### 1.1 Overview

Multi-section wings allow users to define distinct inner and outer wing panels, each with
independent airfoil, sweep angle, and dihedral. The classic use case is polyhedral
(flat inner panel + angled outer panel) common in gliders and hand-launch designs.
The parameters are:

- `wing_sections` (W08): integer 1–4, number of panels per half-wing
- `panel_break_position[n]` (W09): spanwise break position as % of half-span (20–90%)
- `panel_dihedral[n]` (W10): dihedral angle for panel n in degrees (-10–45°)
- `panel_sweep[n]` (W11): sweep angle override for panel n in degrees (-10–45°)

Panel indexing: panel 1 is the innermost (root) panel. The existing `wing_dihedral`
(W07) becomes the dihedral for panel 1. `panel_dihedral[n]` defines dihedral for
panels 2, 3, 4. Similarly for sweep.

### 1.2 CadQuery Coordinate System Reminder

The existing `wing.py` uses `cq.Workplane("XZ")` for lofting. The critical axis mapping:

```
XZ Workplane:
  local X   = global X (chordwise, LE at x=0, TE at x=chord)
  local Y   = global Z (vertical — height above/below waterline)
  local Z   = global -Y (spanwise, outboard direction for right wing)

workplane(offset=N) on XZ plane moves N units along global Y (spanwise)
transformed(offset=(dx, dz, 0)) shifts chordwise (dx) and vertically (dz)
```

This means "moving spanwise to station Y=h" uses `workplane(offset=y_sign * h)`, NOT
`transformed(offset=(0, 0, h))`. This is the most common CadQuery error in this codebase.

### 1.3 Chaining Lofts for Multi-Panel Wings

**Do not attempt a single loft from root to tip.** A multi-section wing must be built
as N separate lofted solids (one per panel), then joined.

For a two-panel right wing with break at `b_span` mm from root:

```python
import math
import cadquery as cq

# Panel 1: root to break
panel1 = (
    cq.Workplane("XZ")
    .spline(root_pts, periodic=False).close()
    .workplane(offset=b_span)  # spanwise to break station
    .transformed(offset=(sweep1_x_at_break, dihedral1_z_at_break, 0))
    .spline(break_pts, periodic=False).close()
    .loft(ruled=False)
)

# Apply panel 1 dihedral as rotation (same as existing single-panel pattern)
if abs(panel1_dihedral) > 1e-6:
    panel1 = panel1.rotate(
        (root_x_center, 0, root_z_center),
        (root_x_center + 1, 0, root_z_center),
        rot_sign * panel1_dihedral
    )

# Panel 2: break to tip
# The break cross-section coordinates must be transformed to match
# where panel 1's tip face actually lands after dihedral rotation.
# Build panel 2 in its own local frame, then translate/rotate to mate.
panel2 = (
    cq.Workplane("XZ")
    .transformed(offset=(break_x_offset, break_z_offset, 0))
    .spline(break_pts, periodic=False).close()
    .workplane(offset=(tip_span - b_span))
    .transformed(offset=(sweep2_x_at_tip, dihedral2_z_increment, 0))
    .spline(tip_pts, periodic=False).close()
    .loft(ruled=False)
)

# Join panels — boolean union
wing_solid = panel1.union(panel2)
```

**Critical:** After dihedral rotation of panel 1, its tip face is no longer at a flat
spanwise plane. Panel 2 must start from the actual 3D position of panel 1's tip face
(accounting for dihedral offset). Compute this position analytically — do not rely on
face selection from the lofted solid, as face selectors on complex lofts are fragile.

### 1.4 Break Cross-Section Position

At panel break position `b_frac` (e.g., 0.60 for 60% of half-span), the break is at
spanwise coordinate `b_span = b_frac * half_span` mm.

The chord at the break is linearly interpolated between root chord and tip chord:
```
chord_at_break = root_chord + (tip_chord - root_chord) * b_frac
```

The airfoil profile at the break uses the root airfoil scaled to `chord_at_break`.
For v0.7, use the same airfoil at all stations (no blending). True tip-to-root airfoil
blending (W13) is a future feature. If a user sets different airfoils per panel in a
future release, the break cross-section uses the outboard panel's airfoil.

### 1.5 Dihedral Accumulation at Panel Boundaries

Dihedral angles are **not** absolute angles measured from horizontal. They are angles
of each panel relative to the previous panel's chord plane. This is the standard RC
model convention (panel dihedral, not total included angle).

The Z-offset (vertical rise) accumulated from root to the start of panel n+1:

```
# For a two-panel wing:
z_at_break = b_span * tan(panel1_dihedral_rad)

# Tip Z (after panel 2 dihedral, measured from where panel 2 starts):
panel2_span = tip_span - b_span
z_at_tip_relative = panel2_span * tan(panel2_dihedral_rad)

# But panel 2's dihedral is measured from the plane of panel 1's tip,
# which is already tilted. The absolute Z at tip:
z_at_tip_absolute = z_at_break + panel2_span * tan(panel2_dihedral_rad)
```

The lateral Y-offset of the tip must account for the fact that dihedral rotates the
panel up (reducing its projected Y extent):

```
# Right wing, panel 1:
y_at_break = b_span * cos(panel1_dihedral_rad)

# Right wing, panel 2 (measured from break):
y_at_tip = y_at_break + panel2_span * cos(panel2_dihedral_rad)
```

**Implementation pattern:** Build each panel with `workplane(offset=panel_y_extent)`
where `panel_y_extent` is the panel's spanwise reach (not its geometric span). Then use
`transformed(offset=(sweep_x, cumulative_z, 0))` to position the outboard cross-section
correctly. Do NOT apply dihedral via `.rotate()` on multi-panel wings — do it through
geometry directly via `transformed` offsets to avoid compound rotation issues.

Alternatively: build all panels flat (zero dihedral), join them, then apply a single
compound rotation. This is simpler but loses the ability to have independent panel
dihedrals. The multi-transform approach (offset per panel) is correct for v0.7.

### 1.6 Sweep Accumulation Across Panels

Leading-edge position must be continuous at the break. The sweep offset formula from
existing `wing.py`:

```python
sweep_offset_x = half_span * math.tan(sweep_rad) + 0.25 * (root_chord - tip_chord)
```

The `0.25 * (root_chord - tip_chord)` term corrects for taper so the quarter-chord
line (not LE) follows the specified sweep angle. For multi-panel wings:

```python
# Panel 1 LE offset at break:
qc_correction_1 = 0.25 * (root_chord - chord_at_break)
sweep_x_at_break = b_span * tan(panel1_sweep_rad) + qc_correction_1

# Panel 2 LE offset at tip, measured from break cross-section:
qc_correction_2 = 0.25 * (chord_at_break - tip_chord)
sweep_x_at_tip_relative = panel2_span * tan(panel2_sweep_rad) + qc_correction_2

# Absolute X offset of tip LE from root LE:
sweep_x_at_tip = sweep_x_at_break + sweep_x_at_tip_relative
```

The leading edge must be continuous at the break (no kink in planform unless that is
intentional). The quarter-chord sweep approach ensures this when the formula above is
applied consistently.

### 1.7 Airfoil Blending at Panel Boundaries

For v0.7, use the root airfoil at all spanwise stations (no blending). Set both the
break cross-section and tip cross-section to the root airfoil scaled to their respective
chord lengths. This is aerodynamically acceptable for typical RC polyhedral planforms
where the break is usually at 50–70% semi-span and chord change is modest.

The break cross-section points are generated using `_scale_airfoil_2d(profile, chord_at_break, wing_incidence_deg)` — same function as existing root and tip sections.

### 1.8 W09 Panel Break Position Mapping

`panel_break_position[n]` is expressed as **percentage of half-span**:

```python
half_span = design.wing_span / 2.0
break_mm = (design.panel_break_position[n] / 100.0) * half_span
```

For n=1 (first break, between panel 1 and panel 2), the default is 60%, so:
- 1000mm wingspan → 500mm half-span → break at 300mm from root

Break positions must be strictly monotonically increasing:
`panel_break_position[0] < panel_break_position[1] < panel_break_position[2]`

The outer edge of the last panel is always at 100% (tip), regardless of user input.

### 1.9 Parameter Model Changes

Add to `AircraftDesign` in `backend/models.py`:

```python
# ── Multi-section wing (W08-W11) ──────────────────────────────────
wing_sections: int = Field(default=1, ge=1, le=4)
# Arrays: index 0 = break between panel 1 and 2, etc.
# Only wing_sections-1 breaks needed; store up to 3 for 4-panel wings.
panel_break_positions: list[float] = Field(
    default_factory=lambda: [60.0, 80.0, 90.0]
)  # % of half-span; only first wing_sections-1 values used
panel_dihedrals: list[float] = Field(
    default_factory=lambda: [10.0, 5.0, 5.0]
)  # deg; panels 2, 3, 4 (panel 1 uses wing_dihedral)
panel_sweeps: list[float] = Field(
    default_factory=lambda: [0.0, 0.0, 0.0]
)  # deg; panels 2, 3, 4 (panel 1 uses wing_sweep); NaN = inherit panel 1
```

The alias generator (`to_camel`) will produce `wingsections`, `panelBreakPositions`,
`panelDihedrals`, `panelSweeps` for the frontend automatically.

Use `populate_by_name=True` (already set on `CamelModel`) so backend code uses
snake_case field names.

### 1.10 Validation Rules to Add (in `backend/validation.py` ONLY)

Add a new `_check_v29` function. Do NOT add validation logic in `wing.py` or `engine.py`.

```python
def _check_v29(design: AircraftDesign, out: list[ValidationWarning]) -> None:
    """V29: Multi-section wing configuration checks."""
    n = design.wing_sections
    if n <= 1:
        return

    # Check break positions are monotonically increasing
    breaks = design.panel_break_positions[:n - 1]
    for i in range(len(breaks) - 1):
        if breaks[i] >= breaks[i + 1]:
            out.append(ValidationWarning(
                id="V29",
                message=(
                    f"Panel break positions must be strictly increasing "
                    f"(break {i+1}={breaks[i]:.0f}% >= break {i+2}={breaks[i+1]:.0f}%)"
                ),
                fields=["panel_break_positions"],
            ))
            return  # further checks invalid

    # Check outermost break leaves a usable outer panel (min 10% span)
    if breaks and breaks[-1] > 90.0:
        out.append(ValidationWarning(
            id="V29",
            message=(
                f"Outermost panel break at {breaks[-1]:.0f}% leaves a very short "
                f"outer panel — minimum 10% semi-span recommended"
            ),
            fields=["panel_break_positions"],
        ))

    # Check outer panel dihedral limits (high dihedral = print overhang)
    dihedrals = design.panel_dihedrals[:n - 1]
    for i, d in enumerate(dihedrals):
        if abs(d) > 30:
            out.append(ValidationWarning(
                id="V29",
                message=(
                    f"Panel {i+2} dihedral ({d:.0f}°) exceeds 30° — "
                    f"large panel dihedral creates significant print overhang"
                ),
                fields=["panel_dihedrals"],
            ))
```

### 1.11 MAC Calculation for Cranked Wings

The existing MAC formula assumes a simple straight taper over the full span. For a
cranked (multi-panel) wing, MAC must be computed as a span-weighted average:

```
# For a two-panel wing:
b_total = wing_span / 2   (half-span)
b1 = b_frac * b_total      (panel 1 span)
b2 = b_total - b1          (panel 2 span)

c_root = wing_chord
c_break = chord_at_break
c_tip = wing_chord * wing_tip_root_ratio

# Panel 1 area and MAC:
S1 = 0.5 * (c_root + c_break) * b1
lam1 = c_break / c_root
MAC1 = (2/3) * c_root * (1 + lam1 + lam1^2) / (1 + lam1)

# Panel 2 area and MAC:
S2 = 0.5 * (c_break + c_tip) * b2
lam2 = c_tip / c_break
MAC2 = (2/3) * c_break * (1 + lam2 + lam2^2) / (1 + lam2)

# Combined:
S_total = S1 + S2
MAC_cranked = (S1 * MAC1 + S2 * MAC2) / S_total
```

This is the aerodynamically correct area-weighted MAC. Update `_mac()` in
`backend/validation.py` and `compute_derived_values()` in `backend/geometry/engine.py`
to use this formula when `wing_sections > 1`.

The CG estimate (`estimated_cg_mm`) should continue to use `0.25 * MAC_cranked` as the
balance point, measured from the root leading edge. For the CG calculator, note that
MAC position along the chord shifts as well — the leading edge of the MAC is inboard
of the break for forward-swept panels. For v0.7, the 25% MAC rule of thumb is sufficient.

### 1.12 Shell and Section Behavior for Multi-Panel Wings

- Shell each panel individually before union. The union of two hollow solids is
  unreliable in CadQuery. Shell after joining is even more unreliable on compound
  solids. Pattern:
  ```python
  if design.hollow_parts:
      panel1 = _shell_wing(panel1, skin_thickness, side)
      panel2 = _shell_wing(panel2, skin_thickness, side)
  wing_solid = panel1.union(panel2)
  ```
- Tessellate the wing as a single solid (the union), not per panel. The viewport
  receives one "wing_left"/"wing_right" component per side.
- Auto-sectioning in `section.py` operates on the assembled union. The smart split
  optimizer (#147) must be aware of panel breaks as additional avoidance zones.

---

## 2. Issue #144 — Control Surfaces

### 2.1 Geometry Architecture: Subtraction, Not Addition

Control surfaces are generated by boolean subtraction from the parent solid. The
workflow for every control surface type is identical:

1. Build the parent solid (wing or tail surface) as normal.
2. Compute the hinge line in 3D space.
3. Build a "cutter" solid — a box or swept volume along the hinge line that captures
   the control surface volume plus the hinge gap.
4. `parent.cut(cutter)` = fixed surface (stays attached to aircraft).
5. Build the control surface solid directly (separate loft or cut from a copy).
6. Return both as separate `cq.Workplane` objects.

Never use boolean union of the parent + control surface. They are separate parts for
separate STL files.

### 2.2 Hinge Gap Specification

Per spec (`aero_parameters.md` section 6.8):
- Hinge gap = **0.5mm per side, 1.0mm total**.
- Why it matters: After FDM printing, the parent and control surface are separate prints.
  They are assembled via hinge pins (piano wire). The 1.0mm total gap allows the
  control surface to rotate freely without binding against the parent surface, even with
  the surface finish roughness of FDM parts. Tighter gaps jam; looser gaps cause flutter.
- The cutter solid is sized to create this gap. The control surface solid is sized to
  fit within the gap. Equivalently: if the hinge line is at chordwise position `x_hinge`,
  the cutter removes from `x_hinge - 0.5mm` to the trailing edge on the parent, and the
  control surface solid is built from `x_hinge + 0.5mm` forward to the trailing edge.

### 2.3 Aileron Geometry

**Parameters:** C01–C05 (`aileron_enable`, `aileron_span_start`, `aileron_span_end`,
`aileron_chord_percent`, `aileron_max_deflection`).

**Hinge line computation:**

The aileron hinge line runs spanwise from `aileron_span_start` to `aileron_span_end`
(as % of half-span), at the chordwise position defined by `aileron_chord_percent`:

```python
aileron_chord_frac = design.aileron_chord_percent / 100.0

# Spanwise extents (right wing, Y > 0):
y_inboard = (design.aileron_span_start / 100.0) * half_span
y_outboard = (design.aileron_span_end / 100.0) * half_span

# Chord at inboard station (linear interpolation with taper):
chord_at_y_inboard = root_chord + (tip_chord - root_chord) * (y_inboard / half_span)
chord_at_y_outboard = root_chord + (tip_chord - root_chord) * (y_outboard / half_span)

# X position of hinge line (from LE):
x_hinge_inboard = chord_at_y_inboard * (1.0 - aileron_chord_frac)
x_hinge_outboard = chord_at_y_outboard * (1.0 - aileron_chord_frac)
```

Note that the hinge line is at `(1 - aileron_chord_percent/100) * local_chord` from
the LE, because aileron_chord_percent is the chord of the control surface (rear portion).

**Building the cutter (aileron volume + gap):**

The cutter is a boolean solid that removes the aileron from the wing. For a simple
plain flap aileron:

```python
# The aileron occupies from x_hinge to TE, y_inboard to y_outboard, full Z
# The cutter must also include the 0.5mm gap on each side of the hinge line.
# Simplest approach: build a swept profile of the aileron cross-section.

# For a rectangular planform approximation (conservative but reliable):
gap = 0.5  # mm per side
cutter = (
    cq.Workplane("XY")
    .transformed(offset=((x_hinge_inboard + x_hinge_outboard)/2 - gap/2,
                          (y_inboard + y_outboard)/2, 0))
    .box(
        (chord_at_midspan * aileron_chord_frac + gap),  # chordwise
        (y_outboard - y_inboard),                        # spanwise
        wing_max_thickness * 3.0                         # Z: oversized, trimmed by wing
    )
)
wing_with_cutout = wing_solid.cut(cutter)
aileron_solid = wing_solid.cut(...)  # opposite cutter
```

**Better approach for tapered wings:** Use two cross-sectional profiles at inboard
and outboard stations and loft the cutter, mirroring the wing loft approach. This
correctly handles taper.

**Spar position constraint:** The aileron hinge line is typically placed at the rear
spar position (W19, `rear_spar_position`, default 70% chord). If `aileron_chord_percent`
is set such that the hinge line would fall forward of the rear spar, fire a validation
warning. The rear spar provides the structural backing for the hinge.

Recommended: `x_hinge / local_chord >= design.rear_spar_position / 100.0 - 0.05`
(5% tolerance). Otherwise: warn V29 or a new V30 validation ID.

### 2.4 Elevator Geometry

**Parameters:** C11–C13 (`elevator_enable`, `elevator_span_percent`, `elevator_chord_percent`).

The elevator is cut from the horizontal stabilizer (h-stab). The h-stab in the existing
codebase uses an elliptical cross-section approximation. The elevator cut is similar to
the aileron cut:

```python
h_stab_chord = design.h_stab_chord
elevator_chord_frac = design.elevator_chord_percent / 100.0
x_hinge = h_stab_chord * (1.0 - elevator_chord_frac)

# Elevator spans elevator_span_percent of total h-stab span.
# Center-symmetric: spans from -y_elev to +y_elev.
half_h_stab = design.h_stab_span / 2.0
y_elev = (design.elevator_span_percent / 100.0) * half_h_stab
```

The cutter removes the aft portion of the h-stab from `x_hinge - 0.5mm` to TE. The
elevator solid is the cut piece.

**Positioning in 3D:** The elevator is part of the h-stab, which is already translated
to `X = wing_x + tail_arm` in the assembly. The cut must be performed in the h-stab's
local frame (before final translation), then the resulting two solids are translated
together.

### 2.5 Rudder Geometry

**Parameters:** C15–C17 (`rudder_enable`, `rudder_height_percent`, `rudder_chord_percent`).

The rudder is cut from the vertical stabilizer. The v-stab extends vertically in +Z.
The rudder cut is similar to aileron/elevator but along the spanwise (Z) axis:

```python
v_stab_root_chord = design.v_stab_root_chord
tip_chord_v = v_stab_root_chord * 0.6  # 60% taper (existing constant in tail.py)
rudder_chord_frac = design.rudder_chord_percent / 100.0

v_stab_height = design.v_stab_height
z_rudder_start = v_stab_height * (1.0 - design.rudder_height_percent / 100.0)

# At any height z, chord = interpolate(v_stab_root_chord, tip_chord_v, z/v_stab_height)
# Hinge line X position at height z:
chord_at_z = v_stab_root_chord + (tip_chord_v - v_stab_root_chord) * (z / v_stab_height)
x_hinge_at_z = chord_at_z * (1.0 - rudder_chord_frac)
```

The rudder hinge line is a straight line in 3D (tapered with the fin). The cutter is
a lofted volume matching the v-stab's profile from `z_rudder_start` to `v_stab_height`.

**Validation:** Rudder height must not exceed fin height: `rudder_height_percent <= 100`.
If `rudder_height_percent = 100`, the entire fin is movable (full-length rudder), which
is aerodynamically valid. Minimum sensible value is 50% (warn below).

### 2.6 Ruddervator Geometry (V-Tail)

**Parameters:** C18–C20 (`ruddervator_enable`, `ruddervator_chord_percent`, `ruddervator_span_percent`).

V-tail ruddervators are the most geometrically complex control surface. Each V-tail
surface already has a diagonal hinge line (the surface is canted at `v_tail_dihedral`
from horizontal).

**Hinge line direction:** The V-tail surface normal vector in 3D is:
```
# For left V-tail surface (the "right" in flying direction = starboard):
# Surface extends in the direction (−sin(dihedral), cos(dihedral)) in Y-Z plane
# Hinge line runs along the surface's spanwise axis, which is:
n_y = cos(dihedral_rad)   # spanwise Y component
n_z = sin(dihedral_rad)   # spanwise Z component

# The ruddervator hinge line is parallel to this spanwise direction.
# At ruddervator_chord_percent from the trailing edge:
x_hinge = v_tail_chord * (1.0 - ruddervator_chord_frac)
```

**Implementation approach for V-tail ruddervator:**

1. Build the full V-tail surface in its local frame (flat, before dihedral rotation).
   At this stage it is a horizontal surface in the XZ plane of a loft.
2. Cut the ruddervator from the flat surface (same as elevator cut in h-stab).
3. Apply the dihedral rotation to both the parent surface and the ruddervator solid
   simultaneously, using the same rotation axis and angle as the V-tail builder.

This is simpler than computing the ruddervator geometry in the rotated frame.

**Ruddervator function:** A ruddervator provides both pitch and yaw control through
differential and collective deflection (handled by radio/transmitter mixing). The
geometry only needs to provide the correct hinge line and surface area — mixing is not
a geometry concern.

**Ruddervator span:** `ruddervator_span_percent` is a percentage of the V-tail surface
span (half-span of the V-tail, not total). The inboard edge of the ruddervator is at:
```
y_inboard = v_tail_span/2 * (1.0 - ruddervator_span_percent/100.0)
y_outboard = v_tail_span/2
```

### 2.7 Elevon Geometry (Flying-Wing)

**Parameters:** C21–C24 (`elevon_enable`, `elevon_span_start`, `elevon_span_end`, `elevon_chord_percent`).

Elevons are the only control surface on flying-wing configurations (tailType = "FlyingWing").
They function as combined aileron (differential) and elevator (collective). The geometry
is identical to an aileron cut — a plain flap extending from `elevon_span_start` to
`elevon_span_end` at `elevon_chord_percent` chord depth.

**Flying-wing specific constraints:**
- Elevons must span the majority of the outer wing (typically 20–90% semi-span).
- The inboard limit should be at least 20% semi-span to avoid fuselage interference.
- The `elevon_chord_percent` default of 20% is conservative — flying wings often use
  25–33% chord for adequate pitch authority.
- Minimum: warn if elevon chord area / wing area < 0.08 (8%). Flying wings rely heavily
  on elevons for pitch, so undersized elevons cause poor pitch response.

### 2.8 Servo Mount Point Geometry

Per spec (`aero_parameters.md` section 6.8): "cylindrical holes along hinge line for
piano wire."

```python
hinge_pin_diameter = design.hinge_pin_diameter  # PR13, default 1.5mm
hinge_pin_hole_diameter = hinge_pin_diameter + 2 * design.joint_tolerance

# Minimum 3 hinge pins per control surface, evenly spaced.
# For a control surface of span S, place pins at 20%, 50%, 80% of span:
pin_positions = [0.2, 0.5, 0.8]  # as fractions of control surface span

for frac in pin_positions:
    # Pin hole center position along hinge line
    y_pin = y_inboard + frac * (y_outboard - y_inboard)
    x_pin = x_hinge_at(y_pin)  # interpolated hinge X at this span station
    # Hole is a cylinder along Z (vertical through the control surface thickness)
    pin_hole = (
        cq.Workplane("XY")
        .transformed(offset=(x_pin, y_pin, 0))
        .circle(hinge_pin_hole_diameter / 2)
        .extrude(wing_max_thickness_at(y_pin) * 2)  # through entire thickness
    )
    # Cut from both parent and control surface
    parent = parent.cut(pin_hole)
    control_surface = control_surface.cut(pin_hole)
```

**For the tail surfaces** (elevator, rudder), the hinge pin holes run horizontally
through the surface thickness (along Y for elevator, along X for rudder).

### 2.9 Why Deflection Angle is Read-Only

`aileron_max_deflection` (C05) is for **validation and annotation only** — it does not
change the 3D geometry. The actual control surface travel is set by servo throw in the
radio system, not by the 3D model. However, the maximum deflection angle is used to:

1. Verify that the hinge pin holes are positioned such that they don't bind at full
   deflection (check that hinge gap * 1 / tan(deflection_rad) > minimum hinge pin
   engagement).
2. Display deflection arc annotations in the 3D viewport (a future UI feature).
3. Drive validation warning V30: if `aileron_max_deflection > 40°`, warn that aggressive
   throws may require more structural reinforcement at the hinge region.

Do not add any geometry that changes with deflection. No swept/rotated control surface
mesh at a deflected angle. The 3D model always shows neutral (0°) position.

### 2.10 Preview Mode Component Registration

In preview mode, each control surface is a **separate tessellated component**. Add
component keys to the assembly dict in `engine.py`:

```python
# Existing components:
# "wing_left", "wing_right", "fuselage", "h_stab_left", "h_stab_right", "v_stab"

# New control surface components (when enabled):
"aileron_left"       # left wing aileron
"aileron_right"      # right wing aileron
"flap_left"          # left wing flap (if enabled)
"flap_right"         # right wing flap
"elevator_left"      # left elevator
"elevator_right"     # right elevator (separate for future use)
"rudder"             # rudder
"ruddervator_left"   # V-tail left ruddervator
"ruddervator_right"  # V-tail right ruddervator
"elevon_left"        # flying-wing elevon
"elevon_right"
```

Each component gets a distinct color in the viewport and appears in the WebSocket
`componentRanges` trailer. This allows users to click-select individual control surfaces.

### 2.11 Validation Rules for Control Surfaces

Add to `backend/validation.py` only:

- **V30a:** Aileron must not overlap flap spanwise. Enforce `aileron_span_start >= flap_span_end + 2.0` (% half-span). The 2% gap = gap seal clearance.
- **V30b:** Rudder height percentage must be ≤ 100%. (Pydantic range constraint also handles this.)
- **V30c:** For flying-wing, elevon chord area / wing area must be ≥ 8%.
- **V30d:** Warn if aileron hinge line falls forward of rear spar position (aileron would interfere with spar).
- **V30e:** Control surface span must be > 3 * nozzle_diameter at minimum (unprintable otherwise).

Use ID "V30" for all control surface warnings (they can share an ID with different
messages, following the existing pattern for V10 which fires multiple times).

---

## 3. Issue #145 — Landing Gear

### 3.1 Geometry Architecture

Landing gear uses the following CadQuery primitive approach:

- **Struts:** Swept rectangular profile (width = 4mm, thickness = 2mm) along a line
  from mount point to axle center. A NACA0006 cross-section is preferred aesthetically
  but complex to implement — use rectangular with chamfered edges as the MVP.
- **Wheels:** Torus primitive (`major_radius = wheel_diameter/2`, `minor_radius = tire_width/2`).
  CadQuery torus: `cq.Workplane("XY").torus(majorRadius, minorRadius)`. The wheel
  torus axis is the Z-axis by default; rotate 90° to orient wheel horizontally.
- **Mounting tabs:** Small rectangular bosses boolean-unioned to the fuselage bottom
  at the `main_gear_position` X coordinate.
- **Wire-guide bracket (alternative):** If user wants to use bent music wire struts
  (common in RC building), generate a bracket with a 1.5mm diameter channel instead of
  a solid strut. This is lighter and more impact-resistant than printed PLA.

### 3.2 Strut Geometry Detail

```python
import math, cadquery as cq

def build_main_strut(design: AircraftDesign, side: str) -> cq.Workplane:
    """Build one main gear strut (left or right)."""
    y_sign = -1.0 if side == "left" else 1.0
    track_half = design.main_gear_track / 2.0
    height = design.main_gear_height

    # Strut cross-section: 4mm wide, 2mm thick (chord-wise x span-wise)
    strut_width = 4.0
    strut_thick = 2.0

    # Strut runs from fuselage bottom (z=0 relative to gear mount) to axle center
    # Axle center is at (track_half, -height) in local frame
    # Use a swept profile: extrude along strut vector
    strut_length = math.sqrt(track_half**2 + height**2)
    strut_angle = math.degrees(math.atan2(track_half, height))  # deg from vertical

    strut = (
        cq.Workplane("XY")
        .rect(strut_width, strut_thick)
        .extrude(strut_length)
        .rotate((0, 0, 0), (1, 0, 0), strut_angle)  # tilt outward
    )

    # Translate to mount position
    gear_x = design.fuselage_length * (design.main_gear_position / 100.0)
    strut = strut.translate((gear_x, y_sign * 0, 0))

    return strut
```

Apply `gear_sweep` (L07, deg) by rotating the strut forward/aft before translating:
```python
if abs(design.gear_sweep) > 1e-6:
    strut = strut.rotate((0, 0, 0), (0, 1, 0), design.gear_sweep)
```

### 3.3 Wheel Geometry

```python
def build_wheel(diameter: float, width: float = 8.0) -> cq.Workplane:
    """Build a wheel as a torus."""
    major_r = diameter / 2.0   # center of tube to center of torus
    minor_r = width / 2.0       # tube cross-section radius
    # Torus in CadQuery is centered at origin, axis = Z
    # Rotate 90° about X to orient wheel for rolling along Y
    wheel = (
        cq.Workplane("XY")
        .torus(major_r, minor_r)
        .rotate((0, 0, 0), (1, 0, 0), 90)
    )
    return wheel
```

Note: CadQuery `torus()` may not exist in all versions. Alternative: revolve a circle
profile about an offset axis:
```python
wheel = (
    cq.Workplane("XZ")
    .transformed(offset=(major_r, 0, 0))
    .circle(minor_r)
    .revolve(360, (0, 0, 0), (0, 1, 0))
)
```

The main wheel diameter is `design.main_wheel_diameter` (L06, default 30mm). The
wheel width is not a user parameter in v0.7 — use a fixed `min(wheel_diameter * 0.25, 10)` mm.

### 3.4 Tricycle vs Taildragger Configuration

**Tricycle configuration** (most common, default):
- Two main gear wheels behind CG, one nose gear wheel in front.
- `main_gear_position` (L03, % fuselage from nose) should be **behind** CG.
- CG is approximately at 25% MAC from wing LE. Wing LE is at `fuselage_length * 0.30`.
- Nose gear is at a fixed position: approximately 15% fuselage from nose (nose gear
  forward position), set by `nose_gear_height` (L08) and wheel diameter.

**Taildragger configuration:**
- Two main gear wheels ahead of or at CG.
- Tail wheel at rear (`tail_gear_position`, L11, default 92% from nose).
- `main_gear_position` should be at or **forward** of CG. Warn if main gear is more
  than 10mm behind CG for taildragger (unstable on ground).
- Tail wheel height is derived from `tail_wheel_diameter` (L10) — no separate height
  parameter; the wheel rests on the ground plane.

**Ground clearance validation:** The propeller must clear the ground with gear installed.
This is validation rule V14 from `aero_parameters.md`:

```
prop_tip_clearance = main_gear_height - (prop_diameter/2 - fuselage_height/2)
```

For tractor configuration: if `prop_tip_clearance < propClearanceMin (P09)`, fire V14.
Add `_check_v14` to `backend/validation.py` when landing gear params are present.

### 3.5 Mounting Tab Geometry

The strut must attach to the fuselage. Generate a flat rectangular tab:

```python
# Mount tab: 15mm long (chordwise), gear strut width wide, 3mm thick
# Union to fuselage bottom
mount_tab = (
    cq.Workplane("XY")
    .transformed(offset=(gear_x, 0, -fuselage_bottom_z))
    .box(15.0, design.main_gear_track * 1.1, 3.0)
)
fuselage = fuselage.union(mount_tab)
```

In practice, attach the tab to the landing gear solid, not the fuselage, since the
fuselage is built separately. The tab is part of the gear assembly that the user
bolts/glues to the fuselage bottom.

### 3.6 CG Impact of Landing Gear

Landing gear adds weight that shifts the CG. For the CG calculator in `engine.py`:

- Wire strut gear (music wire): estimate ~5g per strut + 3g per wheel = ~13g total for
  tricycle configuration (2 main + 1 nose).
- Printed PLA gear: estimate volume of strut + wheel, multiply by 1.24 g/cm³ × infill.
  For typical 15% infill with 2 perimeters, effective density ≈ 0.35 g/cm³.
- Landing gear position for CG: the weight acts at the axle center, which is at
  `(gear_x, ±track_half, -gear_height)` in aircraft coordinates.

Add landing gear weight to `_compute_weight_estimates()` in `engine.py` when gear type
is not "None". Expose as a component in the CG calculator.

### 3.7 Component Registration in WebSocket Trailer

Landing gear is a separate component group in the trailer. Use these keys:

```python
"gear_main_left"     # left main strut + wheel
"gear_main_right"    # right main strut + wheel
"gear_nose"          # nose gear strut + wheel (tricycle only)
"gear_tail"          # tail wheel (taildragger only)
```

Each can be hidden in the viewport independently (useful for showing aircraft without
gear for aerodynamic review).

### 3.8 Print Orientation for Gear

- **Struts:** Print vertically (longest axis = Z, loading direction). This orients
  the FDM layers perpendicular to the tensile/compressive load during landing. Mark
  `print_orientation = "vertical"` in `SectionPart`.
- **Wheels:** Print flat (wheel face on build plate). This makes the tread surface
  smooth and the perimeters strong. Mark `print_orientation = "flat"`.
- **Note to user:** PLA struts are fragile. Add an assembly note in the export manifest:
  "Landing gear struts are printed in PLA and may break on hard landings. Consider
  using PETG/Nylon for struts, or bending music wire and printing wire-guide brackets."

### 3.9 Validation Rules for Landing Gear

Add to `backend/validation.py`:

- **V31a:** For tricycle, if `main_gear_position` is more than 10% of fuselage ahead
  of estimated CG, warn "Main gear forward of CG — may tip tail on ground."
- **V31b:** For taildragger, if `main_gear_position` is behind estimated CG, warn
  "Main gear aft of CG — taildragger will be unstable on ground; move gear forward."
- **V31c:** If `main_gear_height + wheel_diameter/2 < prop_diameter/2` (prop hits
  ground), fire V14 (propeller ground clearance violation).
- **V31d:** If `main_gear_track < 0.4 * main_gear_height`, warn "Narrow gear track
  relative to height — risk of tipover in crosswind landing."

Use IDs "V31" for all landing gear warnings.

---

## 4. Issue #146 — Test Joint Feature

### 4.1 Purpose and Design Intent

The test joint is a small calibration print that allows users to verify joint fit
before committing to a full print run. Printing one set of test pieces (~30 minutes)
identifies fit issues — tight joints, loose joints, or undersized tongues — before
spending hours printing the full aircraft.

### 4.2 Exact Dimensions

The test piece must be small enough to print in under 30 minutes at standard settings
(0.2mm layer height, 15% infill, 60mm/s):

- Block footprint: **40mm × 40mm**
- Block height: **`section_overlap` mm** (PR05, default 15mm) — this is the tongue depth
- The tongue/groove profile is centered on the 40mm × 40mm face
- Total two-piece assembly (plug + socket): 40mm × 80mm when joined

These dimensions produce a ~7cm³ volume per piece, printing in approximately 20 minutes
on an Ender-3-class printer. Within the 30-minute target.

### 4.3 Exact Profile Replication

The tongue profile must exactly replicate what `joints.py` generates. From `joints.py`,
the tongue dimensions are:

```python
# In joints.py, cross_dim_a = dx, cross_dim_b = dz for Y-axis split
# tongue_a = max(cross_dim_a * 0.6, min_tongue_width)
# tongue_b = max(cross_dim_b * 0.6, min_tongue_width)

# For the test piece: simulate a 40mm × 40mm cross-section:
cross_dim_a = 40.0   # mm (test piece width)
cross_dim_b = 40.0   # mm (test piece height)
min_tongue_width = 3.0 * nozzle_diameter

tongue_a = max(cross_dim_a * 0.6, min_tongue_width)   # = max(24, 3*nozzle)
tongue_b = max(cross_dim_b * 0.6, min_tongue_width)   # = max(24, 3*nozzle)

groove_a = tongue_a + 2.0 * joint_tolerance
groove_b = tongue_b + 2.0 * joint_tolerance
groove_depth = section_overlap + 0.2  # _GROOVE_DEPTH_CLEARANCE_MM
```

Then apply the fillet: `_TONGUE_FILLET_RADIUS_MM = 1.0` on edges parallel to the
tongue insertion direction (`|Y`).

The test piece builder should call `add_tongue_and_groove()` from `joints.py` directly
on two 40×40×15mm blocks, rather than re-implementing the geometry. This guarantees
the test piece matches production joints exactly — if joints.py changes, the test piece
automatically reflects the change.

```python
def build_test_joint(design: AircraftDesign) -> tuple[cq.Workplane, cq.Workplane]:
    """Generate plug (tongue side) and socket (groove side) test pieces."""
    import cadquery as cq
    from backend.export.joints import add_tongue_and_groove

    overlap = design.section_overlap   # PR05
    tolerance = design.joint_tolerance  # PR11
    nozzle_d = design.nozzle_diameter  # PR06

    # Build two blocks
    plug = cq.Workplane("XY").box(40.0, overlap, 40.0)    # tongue side
    socket = cq.Workplane("XY").box(40.0, overlap, 40.0)  # groove side

    # Translate socket so they would mate at Y boundary:
    # plug occupies Y=[0, overlap], socket at Y=[overlap, 2*overlap]
    plug = plug.translate((0, overlap / 2, 0))
    socket = socket.translate((0, overlap * 1.5, 0))

    # Add tongue and groove (split_axis="Y")
    plug_with_tongue, socket_with_groove = add_tongue_and_groove(
        plug, socket,
        overlap=overlap,
        tolerance=tolerance,
        nozzle_diameter=nozzle_d,
        split_axis="Y",
    )

    return plug_with_tongue, socket_with_groove
```

### 4.4 Label Embossing

Emboss text on the flat face of each piece:

- Plug (tongue side) label: `"CHENG TEST JOINT"` on top flat face, plus `f"TOL={joint_tolerance:.2f}mm"` on second line.
- Socket (groove side) label: `"CHENG SOCKET"` on top flat face, plus `f"OVERLAP={section_overlap:.0f}mm"`.

CadQuery text emboss approach:

```python
# Emboss text on the +Y face (top) of the test piece
plug_labeled = (
    plug_with_tongue
    .faces(">Y")          # top face
    .workplane()
    .text(f"TOL={tolerance:.2f}mm", fontsize=4, distance=-0.5)  # 0.5mm deep
)
```

Note: `cq.Workplane.text()` requires the `fontPathName` parameter or may not be
available in all CadQuery builds. If text fails, skip labeling gracefully (try/except)
and proceed with unlabeled test pieces. The label is nice-to-have, not critical.

Alternative: Emboss a simple grid pattern on the flat face as a visual reference.

### 4.5 Export Route

Add a new REST endpoint in `backend/routes/export.py`:

```
POST /api/export/test-joint
Request: ExportRequest (same Pydantic model, design params used for joint settings)
Response: ZIP with two STL files + manifest

ZIP contents:
  test_joint_plug.stl      (tongue side)
  test_joint_socket.stl    (groove side)
  manifest.json            {joint_type, joint_tolerance, section_overlap, nozzle_diameter}
```

Follow the same streaming pattern as the main export route:
1. Call `build_test_joint(design)` in thread pool (same `_cadquery_limiter`).
2. Tessellate plug and socket individually.
3. Write to temp ZIP file in `/data/tmp/`.
4. Stream via `FileResponse` with background cleanup task.

**Route registration:** Add to the router in `backend/routes/export.py`, not in a new
file. Register the new route before the existing `/api/export` route so it isn't shadowed.

### 4.6 Print Time Estimate

At standard FDM settings (0.4mm nozzle, 0.2mm layer height, 15% infill, 60mm/s):
- Volume per piece: approximately 40 × 15 × 40 - tongue_volume ≈ 21 cm³
- Print time per piece: approximately 12–18 minutes
- Total for both pieces: 25–35 minutes (within target)

If `section_overlap` is increased by the user (e.g., to 30mm), the pieces are taller
and may take 40–50 minutes. Add a note in the manifest:
`"estimated_print_minutes": round(40 * 40 * section_overlap * 2 / 1000 / 0.9, 0)`
(rough estimate: 0.9 mm³/second print rate at 60mm/s × 0.2mm layer × 0.4mm nozzle).

---

## 5. Issue #147 — Smart Split-Point Optimizer

### 5.1 Problem Statement

The current `_recursive_section()` in `section.py` bisects at the exact midpoint of
the longest axis. This midpoint may fall directly on a spar channel (a hollow cylinder
through the wing) or at the wing-fuselage junction saddle. Cutting through these
features produces:
- Exposed spar channel cross-sections that are too thin to print (the spar hole creates
  a very thin wall at the cut face).
- Junction saddle features that get split, losing alignment geometry.

The optimizer should shift split planes by up to ±20mm to avoid these features.

### 5.2 Feature Avoidance Zones

Two types of avoidance zones for wing sectioning (the only component where this matters
significantly; fuselage can use simple midpoint):

**Zone 1: Spar channels**

Spar channels are cylindrical bores through the wing at chordwise positions defined
by `W18` (main spar, `spar_position`) and `W19` (rear spar, `rear_spar_position`).
Both are expressed as % chord from the LE.

The spar channel runs spanwise from root to tip. Its spanwise extent is 0 to half_span.
The avoidance zone around a spar at any spanwise position Y is:

```python
# Avoid splitting within 5mm of any spar Y-plane cut that would expose spar
# (Spar channels run spanwise, so ANY Y-plane cut would intersect them.
# The avoidance is not about spar chordwise position — it's about the
# structural continuity of the spar across joints.)
#
# However, since all Y-cuts intersect the spar, the real constraint is:
# Don't split within ±5mm of the wing root (where the spar saddle is) and
# don't split within ±10mm of a panel break position (multi-section wing).
```

Wait — this requires clarification. Spar channels run the full spanwise extent of the
wing, so every Y-axis cut intersects the spar. The spar continuity is maintained through
the joint feature: the tongue has the spar channel passing through it. The spar channel
is aligned across sections to within 0.2mm (per spec section 8.3).

The actual structural risk of cutting near a spar is not the spar channel crossing
(which is fine) but cutting through the **root saddle attachment** or **panel break
attachment** features — these are small geometry features that should not be bisected.

**Revised avoidance zones for wing:**

```python
# Zone A: Wing root region (fuselage-wing interface)
# Root attachment features occupy approximately ±15mm from wing root (Y=0 in local frame)
ROOT_ZONE_MM = 15.0

# Zone B: Panel break positions (if wing_sections > 1)
# Panel break feature occupies ±8mm around the break spanwise position
PANEL_BREAK_ZONE_MM = 8.0

# Zone C: Near-tip region
# Don't split within 30mm of the tip (too small to add joints)
TIP_ZONE_MM = 30.0
```

**For fuselage sectioning:**
- Avoidance Zone: wing mount saddle at `fuselage_length * wing_x_fraction` (X axis).
  Avoid ±20mm around the wing saddle X position.
- Battery bay / hatch area: not yet modeled geometrically, skip for v0.7.

### 5.3 Optimizer Algorithm

Replace the midpoint selection in `_recursive_section()` with this algorithm:

```python
def _choose_split_position(
    solid: cq.Workplane,
    axis: int,
    design: AircraftDesign,
    component: str,
) -> float:
    """Choose an optimized split position avoiding internal features.

    Returns the chosen split coordinate along the given axis.

    Strategy:
    1. Compute midpoint of solid's bounding box along axis.
    2. Build list of avoidance zones (min, max) in axis coordinates.
    3. If midpoint is outside all zones, use midpoint.
    4. If midpoint is inside a zone, try offsets: +10, -10, +20, -20mm.
    5. If all offsets are in avoidance zones, use the offset that is closest
       to the zone boundary (least evil).
    6. Clamp result to ensure resulting sections are >= MIN_SEGMENT_MM.

    Args:
        solid:     CadQuery solid being split.
        axis:      0=X, 1=Y, 2=Z.
        design:    AircraftDesign for context (spar positions, etc.).
        component: "wing", "fuselage", "h_stab", etc.

    Returns:
        Absolute coordinate along axis for the split plane.
    """
    bb = solid.val().BoundingBox()
    axis_min = [bb.xmin, bb.ymin, bb.zmin][axis]
    axis_max = [bb.xmax, bb.ymax, bb.zmax][axis]
    midpoint = (axis_min + axis_max) / 2.0

    # Build avoidance zones
    zones = _compute_avoidance_zones(design, component, axis, axis_min, axis_max)

    # Try offsets in order: 0, +10, -10, +20, -20 (mm)
    offsets = [0.0, 10.0, -10.0, 20.0, -20.0]
    candidates = [midpoint + off for off in offsets]

    # Filter to candidates within usable range (leave MIN_SEGMENT_MM on each side)
    MIN_SEGMENT_MM = 30.0
    candidates = [
        c for c in candidates
        if axis_min + MIN_SEGMENT_MM <= c <= axis_max - MIN_SEGMENT_MM
    ]

    if not candidates:
        return midpoint  # fallback: no valid candidates, use midpoint

    # Score each candidate: 0 if outside all zones, else min distance to zone edge
    def score(pos):
        for z_min, z_max in zones:
            if z_min <= pos <= z_max:
                # Inside an avoidance zone: score = distance to nearest zone boundary
                return min(abs(pos - z_min), abs(pos - z_max))
        return 0.0  # outside all zones: best possible score

    best = min(candidates, key=score)
    return best


def _compute_avoidance_zones(
    design: AircraftDesign,
    component: str,
    axis: int,
    axis_min: float,
    axis_max: float,
) -> list[tuple[float, float]]:
    """Return list of (zone_min, zone_max) avoidance zones for split axis."""
    zones = []

    if component in ("wing", "wing_left", "wing_right") and axis == 1:  # Y-axis
        # Zone A: Root region
        root_y = axis_min  # root is at minimum Y (right wing) or max Y (left wing)
        zones.append((root_y, root_y + 15.0))
        zones.append((root_y, root_y - 15.0))  # both directions from root

        # Zone B: Panel break positions (if multi-section)
        if design.wing_sections > 1:
            half_span = design.wing_span / 2.0
            for i in range(design.wing_sections - 1):
                break_frac = design.panel_break_positions[i] / 100.0
                break_y = break_frac * half_span
                # The break is in global coordinates; adjust for side
                # For right wing: Y increases outward from root
                zones.append((break_y - 8.0, break_y + 8.0))

        # Zone C: Near-tip region
        tip_y = axis_max
        zones.append((tip_y - 30.0, tip_y))

    elif component == "fuselage" and axis == 0:  # X-axis
        # Wing mount saddle
        from backend.geometry.engine import _WING_X_FRACTION
        wing_x_frac = _WING_X_FRACTION.get(design.fuselage_preset, 0.30)
        wing_x = design.fuselage_length * wing_x_frac
        zones.append((wing_x - 20.0, wing_x + 20.0))

    return zones
```

### 5.4 Minimum Segment Length

No segment should be shorter than 30mm after splitting. This is the minimum length
for a printable section with joint features:
- Tongue depth: `section_overlap` (default 15mm)
- Remaining body: must be at least 15mm for structural integrity
- Total minimum: 30mm

The `MIN_SEGMENT_MM = 30.0` constant enforces this in the candidate filtering above.

If applying the minimum segment constraint would force all candidates into avoidance
zones, override the avoidance zone check. A 30mm segment with a spar cut is worse than
a segment that hits a zone, but less bad than an unprintable 5mm segment.

### 5.5 Maximum Section Count

Impose a practical limit of **8 sections per wing half**. For a 3000mm wingspan (the
largest supported), on a 220mm bed, 3000/2 = 1500mm / (220-20mm usable) = 7.5 sections.
The limit of 8 provides one extra safety margin.

Modify `_MAX_RECURSION` in `section.py` to also enforce section count:

```python
_MAX_SECTIONS_PER_COMPONENT: int = 8
```

If recursion would produce more than 8 sections for a component, reduce the usable bed
dimension estimate (less aggressive splitting) and warn the user:
`"Wing exceeds maximum of 8 sections — consider increasing print bed size or reducing wingspan."`

### 5.6 Returning Split Position in SectionPart Metadata

The `SectionPart` dataclass should be extended with the chosen split position:

```python
@dataclass
class SectionPart:
    # ... existing fields ...
    split_position_mm: float = 0.0   # Absolute coordinate of the split plane
    avoidance_zone_hit: bool = False  # True if optimizer moved from ideal midpoint
```

The frontend can display these split positions in the export preview visualization,
showing where each section boundary is relative to the aircraft model.

### 5.7 Integration with Auto-Section

The `_recursive_section()` function signature needs a `design` parameter and
`component` string added:

```python
def _recursive_section(
    cq_mod: type,
    solid: cq.Workplane,
    usable_x: float,
    usable_y: float,
    usable_z: float,
    depth: int,
    last_split_axis: str = "Y",
    design: AircraftDesign | None = None,   # NEW
    component: str = "",                    # NEW
) -> list[tuple[cq.Workplane, str]]:
```

The public `auto_section_with_axis()` function also needs these parameters passed
through. Update all callers in `backend/geometry/engine.py` and `backend/routes/export.py`
to pass `design` and `component`.

The `auto_section()` convenience function remains backward-compatible by defaulting
to `design=None, component=""` — in which case `_choose_split_position()` returns
the plain midpoint (no optimization).

---

## 6. Cross-Cutting Engineering Constraints

### 6.1 Tessellation: No Boolean Union for Preview

All new components must be tessellatable individually. The preview pipeline in
`backend/geometry/tessellate.py` tessellates each component separately. Do not
attempt to boolean-union components for preview.

```python
# CORRECT:
components = {
    "wing_left": wing_left_solid,
    "aileron_left": aileron_left_solid,
    "gear_main_left": gear_strut_left_solid,
    ...
}
for name, solid in components.items():
    verts, norms, faces = tessellate(solid)
    # append to mesh buffer with component range tracking

# WRONG: do not do this
full_wing = wing_left.union(aileron_left)
verts, norms, faces = tessellate(full_wing)  # loses component boundaries
```

If a solid fails tessellation (CadQuery boolean union artifacts, degenerate geometry),
catch the exception per-component and log it. Do not fail the entire preview for one
bad component.

### 6.2 Shell-Before-Union Pattern

For any component that consists of multiple CadQuery solids (e.g., multi-panel wing,
landing gear assembly), shell each sub-solid individually before union:

```python
if design.hollow_parts:
    panel1 = _shell_wing(panel1, skin_thickness, side)
    panel2 = _shell_wing(panel2, skin_thickness, side)
result = panel1.union(panel2)
```

Shelling after union fails on compound solids with non-manifold junctions. The existing
`_shell_wing()` try/except fallback handles cases where shelling fails.

### 6.3 models.py — Parameter Addition Protocol

When adding new parameters to `AircraftDesign`:

1. Add snake_case field with `Field(default=..., ge=..., le=...)`.
2. Add type annotation with `Literal[...]` for enums, `float` for numerics, `bool` for toggles, `list[float]` for arrays.
3. Add new `Literal` types to the module-level type aliases.
4. The `alias_generator=to_camel` on `CamelModel` automatically generates camelCase aliases.
5. `populate_by_name=True` ensures both snake_case and camelCase work.
6. Add defaults that produce the same behavior as the current single-panel wing (backward compatible).

New parameter groups for v0.7:

```python
# ── Multi-section wing ────────────────────────────────────────────
wing_sections: int = Field(default=1, ge=1, le=4)
panel_break_positions: list[float] = Field(default_factory=lambda: [60.0, 80.0, 90.0])
panel_dihedrals: list[float] = Field(default_factory=lambda: [10.0, 5.0, 5.0])
panel_sweeps: list[float] = Field(default_factory=lambda: [0.0, 0.0, 0.0])

# ── Control surfaces ──────────────────────────────────────────────
aileron_enable: bool = False
aileron_span_start: float = Field(default=55.0, ge=30.0, le=70.0)
aileron_span_end: float = Field(default=95.0, ge=70.0, le=98.0)
aileron_chord_percent: float = Field(default=25.0, ge=15.0, le=40.0)
aileron_max_deflection: float = Field(default=25.0, ge=10.0, le=45.0)

flap_enable: bool = False
flap_span_start: float = Field(default=10.0, ge=5.0, le=30.0)
flap_span_end: float = Field(default=50.0, ge=30.0, le=65.0)
flap_chord_percent: float = Field(default=25.0, ge=15.0, le=40.0)

elevator_enable: bool = False
elevator_span_percent: float = Field(default=100.0, ge=50.0, le=100.0)
elevator_chord_percent: float = Field(default=35.0, ge=20.0, le=50.0)

rudder_enable: bool = False
rudder_height_percent: float = Field(default=90.0, ge=50.0, le=100.0)
rudder_chord_percent: float = Field(default=35.0, ge=20.0, le=50.0)

ruddervator_enable: bool = False
ruddervator_chord_percent: float = Field(default=35.0, ge=20.0, le=50.0)
ruddervator_span_percent: float = Field(default=90.0, ge=60.0, le=100.0)

elevon_enable: bool = False
elevon_span_start: float = Field(default=20.0, ge=10.0, le=40.0)
elevon_span_end: float = Field(default=90.0, ge=60.0, le=98.0)
elevon_chord_percent: float = Field(default=20.0, ge=15.0, le=35.0)

hinge_pin_diameter: float = Field(default=1.5, ge=0.8, le=3.0)

# ── Landing gear ──────────────────────────────────────────────────
LandingGearType = Literal["None", "Tricycle", "Taildragger", "Skid"]
landing_gear_type: LandingGearType = "None"
main_gear_position: float = Field(default=35.0, ge=25.0, le=55.0)
main_gear_height: float = Field(default=40.0, ge=15.0, le=150.0)
main_gear_track: float = Field(default=120.0, ge=30.0, le=400.0)
main_wheel_diameter: float = Field(default=30.0, ge=10.0, le=80.0)
nose_gear_height: float = Field(default=45.0, ge=15.0, le=150.0)
nose_wheel_diameter: float = Field(default=20.0, ge=8.0, le=60.0)
tail_wheel_diameter: float = Field(default=12.0, ge=5.0, le=40.0)
tail_gear_position: float = Field(default=92.0, ge=85.0, le=98.0)
gear_sweep: float = Field(default=5.0, ge=-15.0, le=30.0)
```

### 6.4 Validation Module Convention

All validation logic must live in `backend/validation.py`. Do not add validation
in `engine.py`, `wing.py`, `tail.py`, or any other geometry module. The ID allocation
for v0.7:

| ID Range | Purpose |
|----------|---------|
| V01–V08  | Structural/geometric (existing) |
| V09–V13  | Aerodynamic/structural analysis (existing) |
| V16–V23  | 3D printing (existing) |
| V24–V28  | Printability analysis (existing) |
| V29      | Multi-section wing configuration |
| V30      | Control surface configuration |
| V31      | Landing gear configuration |

Call all new check functions from `compute_warnings()` at the bottom of `validation.py`.

### 6.5 Test Requirements

Each new geometry feature requires backend tests in `tests/backend/`. Follow the
existing patterns in `tests/backend/test_geometry_generation.py`:

- At minimum: one test that generates the feature without error (smoke test).
- For control surfaces: test that the boolean subtraction produces non-zero-volume
  solids for both parent and control surface.
- For landing gear: test that gear is positioned below fuselage (Z center < 0).
- For test joint: test that two pieces can be assembled (tongue bounding box fits
  within groove bounding box + tolerance).
- For smart splits: test that chosen split positions avoid avoidance zones.
- For multi-panel wings: test that panel1.union(panel2) produces a valid solid
  (non-zero volume, no degenerate faces).

### 6.6 Performance Constraints

- Multi-panel wing (4 panels): should complete in < 8s on development machine.
- Control surfaces (full set on conventional tail): < 3s additional overhead.
- Landing gear: < 2s.
- Test joint: < 5s (only called on explicit user request, not preview loop).
- Smart split: < 1s (it is pure math, no CadQuery).

The `CapacityLimiter(4)` shared limiter applies to all CadQuery operations. Control
surface boolean subtraction is particularly prone to slowness on complex airfoil
lofts — if a single `.cut()` takes > 3s, log a warning and consider simplifying
the cutter geometry (rectangular approximation instead of swept profile).

### 6.7 Backward Compatibility

All new parameters have defaults that produce behavior identical to the existing
single-panel wing with no control surfaces and no landing gear. Existing saved designs
(`.cheng` JSON files) will deserialize correctly because Pydantic uses the declared
defaults for missing fields (`populate_by_name=True`). Do not change any existing
default values.

### 6.8 Aircraft Coordinate System Reference

All geometry is in the aircraft coordinate system:
```
Origin:  Nose tip
+X:      Aft (tail direction)
+Y:      Starboard (right wing tip direction)
+Z:      Up (dorsal / above)
```

Wing right half: Y > 0 (extends in +Y from root at Y=0)
Wing left half: Y < 0 (extends in -Y from root at Y=0)
V-stab: extends in +Z
H-stab: extends in ±Y at X = wing_x + tail_arm
Landing gear: extends in -Z from fuselage bottom

The XZ workplane loft for wings: local Y maps to global Z (vertical). Local Z maps to
global -Y (spanwise, toward starboard when `y_sign = +1`). `workplane(offset=d)` moves
`d` units along global Y (spanwise). This is the single most important axis mapping to
remember when implementing wing geometry in CadQuery.

---

*End of v0.7 Aerospace Engineering Guidance*

*Worker agents: read Section 6.8 coordinate system reference before writing any geometry
code. Re-read the XZ workplane axis mapping notes in Section 1.2 whenever debugging
unexpected geometry orientation.*
