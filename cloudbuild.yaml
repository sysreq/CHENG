# Cloud Build pipeline for CHENG — Parametric RC Plane Generator
#
# Triggered on push to main. Builds the Docker image, pushes it to
# Artifact Registry, and deploys to Cloud Run.
#
# Required substitutions (set in Cloud Build trigger or passed via --substitutions):
#   _REGION          GCP region, e.g. us-central1
#   _SERVICE         Cloud Run service name, e.g. cheng
#   _REPOSITORY      Artifact Registry repository name, e.g. cheng-images
#
# These are derived automatically:
#   $PROJECT_ID      injected by Cloud Build
#   $COMMIT_SHA      injected by Cloud Build
#
# Setup (one-time):
#   1. Enable APIs: Cloud Build, Cloud Run, Artifact Registry
#      gcloud services enable cloudbuild.googleapis.com run.googleapis.com artifactregistry.googleapis.com
#
#   2. Create Artifact Registry repository:
#      gcloud artifacts repositories create cheng-images \
#        --repository-format=docker --location=${_REGION}
#
#   3. Grant Cloud Build SA the Cloud Run Admin + AR Writer + SA User roles:
#      PROJECT_NUMBER=$(gcloud projects describe $PROJECT_ID --format='value(projectNumber)')
#      CB_SA="${PROJECT_NUMBER}@cloudbuild.gserviceaccount.com"
#      gcloud projects add-iam-policy-binding $PROJECT_ID \
#        --member="serviceAccount:${CB_SA}" --role="roles/run.admin"
#      gcloud projects add-iam-policy-binding $PROJECT_ID \
#        --member="serviceAccount:${CB_SA}" --role="roles/artifactregistry.writer"
#      gcloud projects add-iam-policy-binding $PROJECT_ID \
#        --member="serviceAccount:${CB_SA}" --role="roles/iam.serviceAccountUser"

substitutions:
  _REGION: us-central1
  _SERVICE: cheng
  _REPOSITORY: cheng-images

steps:
  # Step 1: Pull cache images (best-effort — don't fail if registry is cold)
  - name: gcr.io/cloud-builders/docker
    id: pull-cache
    entrypoint: bash
    args:
      - -c
      - |
        docker pull "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:fe-cache" || true
        docker pull "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:latest" || true

  # Step 2: Build the frontend-build stage and tag it for cache reuse.
  # Caching this intermediate stage separately ensures `pnpm build` only
  # runs when frontend source files actually change, not on every deploy.
  - name: gcr.io/cloud-builders/docker
    id: build-frontend
    env:
      - DOCKER_BUILDKIT=1
    args:
      - build
      - --target
      - frontend-build
      - --build-arg
      - BUILDKIT_INLINE_CACHE=1
      - --cache-from
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:fe-cache"
      - --tag
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:fe-cache"
      - .
    waitFor:
      - pull-cache

  # Step 3: Build the production Docker image using both cache sources
  - name: gcr.io/cloud-builders/docker
    id: build
    env:
      - DOCKER_BUILDKIT=1
    args:
      - build
      - --target
      - runtime
      - --build-arg
      - BUILDKIT_INLINE_CACHE=1
      - --cache-from
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:fe-cache"
      - --cache-from
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:latest"
      - --tag
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:${COMMIT_SHA}"
      - --tag
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:latest"
      - .
    waitFor:
      - build-frontend

  # Step 4: Push all tags to Artifact Registry (runtime + fe-cache)
  - name: gcr.io/cloud-builders/docker
    id: push
    args:
      - push
      - --all-tags
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}"
    waitFor:
      - build

  # Step 5: Deploy to Cloud Run
  - name: gcr.io/google.com/cloudsdktool/cloud-sdk:slim
    id: deploy
    entrypoint: gcloud
    args:
      - run
      - deploy
      - "${_SERVICE}"
      - --image
      - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:${COMMIT_SHA}"
      - --region
      - "${_REGION}"
      - --platform
      - managed
      - --memory
      - 2Gi
      - --cpu
      - "2"
      - --min-instances
      - "1"
      - --max-instances
      - "10"
      - --concurrency
      - "4"
      - --timeout
      - "3600"
      - --cpu-boost
      - --set-env-vars
      - CHENG_MODE=cloud
      - --allow-unauthenticated
    waitFor:
      - push

images:
  - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:${COMMIT_SHA}"
  - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:latest"
  - "${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_REPOSITORY}/${_SERVICE}:fe-cache"

options:
  # Use a high-CPU machine to keep the CadQuery/OCC build fast
  machineType: E2_HIGHCPU_8
  logging: CLOUD_LOGGING_ONLY

timeout: 1800s
